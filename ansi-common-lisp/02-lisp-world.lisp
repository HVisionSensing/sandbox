;;;
;;; @see ANSI Common Lisp, Chapter 02
;;;

;;;;------------------------------------
;;; 2.1 式
;;;;------------------------------------

;;; 全てのLispの式は、アトム（例えば1やt）かリスト（0個以上の式を括弧でくくったもの）

;;;;------------------------------------
;;; 2.2 評価
;;;;------------------------------------

;;;;------------------------------------
;;; 2.3 データ
;;;;------------------------------------

;;;;------------------------------------
;;; 2.4 リストオペレータ
;;;;------------------------------------

;;;;------------------------------------
;;; 2.5 真
;;;;------------------------------------

;;; Lispでは真偽を判別する関数を述語(predicate)と呼ぶ

;;; listp : リストに対して真を返す
(listp '(1 2 3)) ;; ==> T
(listp nil) ;; ==> T
(listp 27)  ;; ==> NIL

;;; null : 空リストに対して真を返す
(null '(1 2 3)) ;; ==> NIL
(null nil) ;; ==> T
(null ())  ;; ==> T
(null 27)  ;; ==> NIL

;;; not : 偽である引数に対して真を返す
(not nil)  ;; ==> T

;;; if : テスト式、then式、else式の3つを引数に取り
;;;      テスト式の真偽に応じてthen/else式を評価しその値を返す
(if (listp '(1 2 3))
	'(i am list)
    '(i am not list)) ;; ==> I AM LIST

;;; and : 全ての引数が真の場合、最後の引数を返す
;;; or  : 真となる引数を見つけた時点で、その引数を返す (残りの引数は評価しない)
(and t (+ 1 2) (+ 3 4))  ;; ==> 7
(or nil (- 1 2) (/ 1 0)) ;; ==> -1 ((/ 1 0)は評価されない)


;;;;------------------------------------
;;; 2.6 関数
;;;;------------------------------------

;;; defunで新しい関数を定義できる
(defun my-third (lst)
  (car (cdr (cdr lst))))


;;;;------------------------------------
;;; 2.7 再帰
;;;;------------------------------------

(defun my-member (obj lst)
  (if (null lst)
	  nil
	  (if (eql (car lst) obj)
		  lst
		  (my-member obj (cdr lst)))))

(my-member 'b '(a b c)) ;; ==> (B C)
(my-member 'z '(a b c)) ;; ==> NIL


;;;;------------------------------------
;;; 2.8 Lispのコードの読み書き
;;;;------------------------------------

;;;;------------------------------------
;;; 2.9 入出力
;;;;------------------------------------

;;; format : printfライクな出力関数
(format t "~A plus ~A equals ~A. ~%" 2 3 (+ 2 3))

;;; read : プロンプトを表示し入力されたものを返す関数
(defun askem (string)
  (format t "~A" string)
  (read))


;;;;------------------------------------
;;;; 2.10 変数
;;;;------------------------------------

;;; let : ローカル変数を導入
(defun ask-number ()
  (format t "please enter a number : ")
  (let ((value (read))) ; valueはローカル変数
	(if (numberp value)
		value
	    (ask-number))))

;;; defparameter : グローバル変数を導入
;; 必ずしも * * をつける必要はないが、Lispの慣習としてつける
(defparameter *glob* 99)

;;; defconstant : グローバル定数を定義
(defconstant limit (+ 1 *glob*))

;;; boundp : シンボルがグローバル変数/定数で使われているかチェック
(boundp '*glob*)


;;;;------------------------------------
;;;; 2.11 代入
;;;;------------------------------------

;;; setf : いずれの種類の変数へも代入できる

(setf *glob* 98) ; ==> 98

(let ((n 10))
  (setf n 2)
  n) ; ==> 2

(setf x (list 'a 'b 'c)) ; ==> (A B C)
                         ; xは暗黙的にグローバル変数とみなされる
                         ; もちろんソースファイル上では、
                         ; 明示的にdefparameterを使う方が望ましい

(set (car x) 'n) ; ==> (N B C)

;; 複数の変数に代入することも可能
(setf a 1
	  b 2
	  c 3)


;;;;------------------------------------
;;;; 2.12 関数プログラミング
;;;;------------------------------------

;;; removeは非破壊的
(setf lst '(c a r a t))
(remove 'a lst) ; ==> (C R T)
lst ; ==> (C A R A T)

;;; 本当にリストを更新したい場合はsetfを使う
(setf lst (remove 'a lst))

;;; remove (に限らず) が非破壊的なのは、関数の副作用を避けるため
;;; (副作用とは、関数の出力以外で変数の変更を行うこと)
;;; これは関数プログラミングにとって重要な概念.


;;;;------------------------------------
;;;; 2.13 反復
;;;;------------------------------------

;;; do : 反復オペレータの代表的マクロ
(defun show-squares-iter (start end)
  (do ((i start (+ i 1)))            ; 第１引数で変数定義と初期値の設定を行う
	  ((> i end) 'done)              ; 第２引数の第１式は反復の終了条件テスト
                                     ; 第２引数の第２式は反復が終了した時に実行される式
	(format t "~A ~A ~%" i (* i i))  ; 残りの引数は反復毎に評価される式
	))

;;; これを再帰で書き直す
(defun show-squares-recur (start end)
  (if (> start end)
	  'done
	  (let ((i start))
		(progn
		  (format t "~A ~A ~%" start (* i i))
		  (show-squares-recur (+ i 1) end)
		  ))))


;;; dolist : リストの要素毎に反復処理を行う
(defun my-length-iter (lst)
  (let ((length 0))
	(dolist (obj lst)                  ; 第１引数で要素を変数に取り出す
	  (setf length (+ 1 length)))      ; 第２引数は要素を取り出す度に実行される式
	length))

;;; これを再帰で書き直す
(defun my-length-recur (lst)
  (if (null lst)
	  0
	  (+ 1 (my-length-recur (cdr lst)))))


;;;;------------------------------------
;;;; 2.14 オブジェクトとしての関数
;;;;------------------------------------

;;; function : 関数名と結びついたオブジェクトを返す

(function my-length-recur)
; ==> #<FUNCTION MY-LENGTH-RECUR (LST) (DECLARE (SYSTEM::IN-DEFUN MY-LENGTH-RECUR))
      (BLOCK MY-LENGTH-RECUR (IF (NULL LST) 0 (+ 1 (MY-LENGTH-RECUR (CDR LST)))))>

(function +)
; ==> #<SYSTEM-FUNCTION +>

;;; #' : functionの省略形

#'my-length-iter
; ==> #<FUNCTION MY-LENGTH-RECUR (LST) (DECLARE (SYSTEM::IN-DEFUN MY-LENGTH-RECUR))
      (BLOCK MY-LENGTH-RECUR (IF (NULL LST) 0 (+ 1 (MY-LENGTH-RECUR (CDR LST)))))>

#'+
; ==> #<SYSTEM-FUNCTION +>


;;; apply : 関数とその関数の引数リストを引数とし、関数の実行結果を返す

(apply #'+ (list 1 2 3))     ; ==> 6
(apply #'+ 1 2 (list 3 4 5)) ; ==> 15 : 最後がリストであれば任意の引数が取れる
(apply #'+ 1 2 3)            ; ==> これはエラー

;;; funcall : applyと同じことを行うが、引数がリストである必要がない

(funcall #'+ 1 2 3) ; ==> 6


;;; lambda : 無名関数を定義する

((lambda (x) (+ x 100)) 1) ; ==> 101 : 無名関数を即時実行
(funcall #'(lambda (x) (+ x 100))
		 1)                ; ==> 101


;;;;------------------------------------
;;;; 2.15 データ型
;;;;------------------------------------

;;; Common Lispでは値は型を持つが、変数は型を持たない

;;; オブジェクトには常に複数の型を持つ
;;;
;;; 例えば 27 という数は
;;; - 固定数 (fixnum)
;;; - 整数 (integer)
;;; - 有理数 (relational)
;;; - 実数 (real)
;;; - 数 (number)
;;; - アトム (atom)
;;; - t 
;;; に当てはまる


;;;;------------------------------------
;;;; 2.16 これから先のこと
;;;;------------------------------------


